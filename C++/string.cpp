#include "pch.h"
#include "string.h"

// вывод строки с помощью указателя на символ
void Hello()
{
	const char *message;
	char privet[] = "and bye!";
	char *pr = privet;

	message = "Hello";
	cout << message << " " << pr << "\n";
	int i = 0;
	while (*(pr + i) != '\0')
	{
		cout << *(pr + i++) << " ";
	}
}

// функция содержит локальный массив строк и при обращении к ней возвращает указатель на нужную строку
char const *month_name(int k)  /* Название k-го месяца */
{
	static const char *name[] = {
							"none","January",
							"February","March","April",
							"May","June","July","August",
							"September","October","November",
							"December"
	};
	return (k < 1 || k > 12) ? name[0] : name[k];
}
/*
for (int i=0; i < 12; i++)
		 cout << "Month number " << i << " - " <<  month_name(i) <<"\n";
*/

/*
string.h.

int getchar(); - Возвращает значение символа (если он есть), который пользователь набрал на клавиатуре. После ввода символа нужно нажать клавишу Enter. Заголовочный файл - stdio.h
int getch(); - Аналогично предыдущему, только символ на экране не отображается. Используется чаще для организации задержки выполнения программы. Заголовочный файл - conio.h
int putchar(int c); - Выводит символ c на экран. В случае успеха возвращает сам символ c, в противном случае - EOF. Заголовочный файл - stdio.h
char *gets(char *s); - Читает символы, включая пробелы и табуляции, до тех пор, пока не встретится символ новой строки, который заменяется нулевым символом. Последовательность прочитанных символов запоминается в области памяти, адресуемой аргументом s. В случае успеха возвращает аргумент s, в случае ошибки - нуль. Заголовочный файл - stdio.h
int puts(const char *s); - Выводит строку, заданную аргументом const char *s. Заголовочный файл - stdio.h
char *strcat(char *dest, const char *scr); - Объединяет исходную строку scr и результирующую строку dest, присоединяя первую к последней. Возвращает dest.
char *strncat(char *dest, const char *scr, int maxlen); - Объединяет maxlen символов исходной строки scr и результирующую строку dest, присоединяя часть первой к последней. Возвращает dest.
char *strchr(const char *s, int c); - Ищет в строке s первое вхождение символа c, начиная с начала строки. В случае успеха возвращает указатель на найденный символ, иначе возвращает нуль.
char *strrchr(const char *s, int c); - Аналогично предыдущему, только поиск осуществляется с конца строки.
int strcmp(const char *s1, const char *s2); - Сравнивает две строки. Возвращает отрицательное значение, если s1<s2; нуль, если s1==s2; положительное значение, если s1>s2. Параметры - указатели на сравниваемые строки.
int stricmp(const char *s1, const char *s2); - Аналогично предыдущему, только сравнение осуществляется без учета регистра символов.
int strncmp(const char *s1, const char *s2, int maxlen); - Аналогично предыдущему, только сравниваются первые maxlen символов.
int strnicmp(const char *s1, const char *s2, int maxlen); - Аналогично предыдущему, только сравниваются первые maxlen символов без учета регистра.
int strcspn(const char *s1, const char *s2); - Возвращает длину максимальной начальной подстроки строки s1, не содержащей символов из второй строки s2.
int strlen(const char *s); - Возвращает длину строки s - количество символов, предшествующих нулевому символу.
char *strlwr(char *s); - Преобразует все прописные (большие) буквы в строчные (малые) в строке s.
char *strupr(char *s); - Преобразует все строчные (малые) буквы в прописные (большие) в строке s.
char *strnset(char *s, int c, int n); - Заполняет строку s символами c. Параметр n задает количество размещаемых символов в строке.
char *strpbrk(const char *s1, const char *s2); - Ищет в строке s1 первое вхождение любого символа из строки s2. Возвращает указатель на первый найденный символ или нуль - если символ не найден.
char *strrev(char *s); - Изменяет порядок следования символов в строке на обратный (кроме завершающего нулевого символа). Функция возвращает строку s.
char *strset(char *s, int c); - Заменяет все символы строки s заданным символом c.
int strspn(const char *s1, const char *s2); - Вычисляет длину максимальной начальной подстроки строки s1, содержащей только символы из строки s2.
char *strstr(const char *s1, const char *s2); - Ищет в строке s1 строку s2. Возвращает адрес первого символа вхождения строки s2. Если строка отсутствует - возвращает нуль.
char *strtok(char *s1, const char *s2); - Делит исходную строку s1 на лексемы (подстроки), разделенные одним или несколькими символами из строки s2.
double atof(const char *s); - Преобразует строку s в число с плавающей точкой типа double. Заголовочный файл - math.h
int atoi(const char *s); - Преобразует строку s в число типа int. Возвращает значение или нуль, если строку преобразовать нельзя. Заголовочный файл - stdlib.h
long atol(const char *s); - Преобразует строку s в число типа long. Возвращает значение или нуль, если строку преобразовать нельзя. Заголовочный файл - stdlib.h
char *itoa(int value, char *s, int radix); - Преобразует значение целого типа value в строку s. Возвращает указатель на результирующую строку. Значение radix - основание системы счисления, используемое при преобразовании (от 2 до 36). Заголовочный файл - stdlib.h
*/

// ввод строки с пробелами в консоли и вывод её длины
void input_str()
{
	const int MAXLEN = 256;
	char string[MAXLEN]; /* Место для 255 символов. */

	cout << "Input string:: ";
	gets_s(string);
	cout << "\n";/* Начать новую строку. */
	cout << "String: " << string << "\n";
	cout << "Length = " << strlen(string);
}

/*
char*с1 = new char [10];
char*с2 = new char [10];
c1=c2;// память выделенная под с1 - потерялась(теперь с1 указывает на память выделенную под с2)

strcpy(с1, с2) - копирует символы, адресуемые указателем с2, в память, адресуемую указателем с1, включая завершающие нули;
*/

/*
Аналогичная функция strncpy() ограничивает количество копируемых символов. Если источник (source) и приемник (destination) являются указателями типа char * или символьными массивами, то оператор
strncpy(destination, source, 10);
скопирует до 10 символов из строки, адресуемой указателем source, в область памяти, адресуемую указателем destination. Если строка source имеет больше 10 символов, то результат усекается. Если же меньше - неиспользуемые байты результата устанавливаются равными нулю.
*/

// конкатенация строк
void concat_str()
{
	//Резервирование места для ввода трех строк.
	char *fam = new char[128];
	char *im = new char[128];
	char *otch = new char[128];
	//Ввод данных.
	cout << "Enter" << "\n";
	cout << "\tSurname: ";
	cin >> fam;
	cout << "\tName: ";
	cin >> im;
	cout << "\tLastname: ";
	cin >> otch;
	//Резервирование места для результата.
   //Нужно учесть два пробела и результирующий
   //нулевой символ.
	char *rez = new char[strlen(fam) + strlen(im) + strlen(otch) + 3];
	//"Сборка" результата.  
	strcat(strcat(strcpy(rez, fam), " "), im);
	strcat(strcat(rez, " "), otch);
	//если strcat() выдаёт предупреждение, надо в с свойствах проекта: C/C++ - Preprocessor - Preprocessor Definitions прописать _CRT_SECURE_NO_WARNINGS
	//Возврат памяти в кучу.
	delete[] fam;
	delete[] im;
	delete[] otch;
	//Вывод результата.
	cout << "\nResult: " << rez;
	delete[] rez;
}

/*
const int MAXLEN=128
char s1[MAXLEN] = "Cat";
char s2[] = "in hat";

strcat(s1, s2);
Если вы не уверены, что в s1 достаточно места, чтобы запомнить результат, используйте альтернативный оператор:
strncat(s1, s2, (MAXLEN-1)-strlen(s1));
Этот способ гарантирует, что s1 не переполнится, даже если s2 нужно будет урезать до подходящего размера. Этот оператор прекрасно работает, если s1 - нулевая строка.
*/

// поиск точки в введённой строке. Если точка не найдена, то к строке дописывается .TXT
void find_extension()
{
	char *filename = new char[128];
	cout << "Enter name of file: ";
	cin >> filename;
	cout << "\nName of file: " << filename << "\n";
	if (strchr(filename, '.'))
		cout << "Name has extension" << "\n";
	else
		strcat(filename, ".TXT");
	cout << "Name of file: " << filename << "\n";
	delete[] filename;
}

// поиск подстрок
void find_substr()
{
	char *filename = new char[128], *p;
	cout << "Enter name of file: ";
	cin >> filename;
	cout << "\nName of file: " << filename << "\n";
	//strupr(filename);
	p = strstr(filename, ".TXT"); // strstr() возвращает адрес подстроки или нуль
	if (p)
		cout << "Name has extension" << "\n";
	else
	{
		p = strchr(filename, '.');
		if (p)
			*p = NULL; //Удалить любое другое расширение(установит вместо точки нулевой байт).
		strcat(filename, ".TXT");
	}
	cout << "Name of file: " << filename << "\n";
	delete[] filename;
}

// замена в слове X всех букв "a" на сочетание "ky"
void change_str1()
{
	/*
		k - переменная для прохода по оригинальному массиву
		i - переменная для прохода по результативному массиву
		n - длина оригинального массива
	*/
	int k = 0, i = 0, n;
	/*
		x1 - оригинальный массив
		x2 - результативный массив (больше в два раза, на
			случай, если оригинальный весь заполнен буквами 'a')
		px1 - указатель для перемещения по оригинальному массиву
		px2 - указатель для перемещения по результативному массиву
	*/
	char x1[40], x2[80], *px1, *px2;

	// Запрос на ввод оригинального массива
	puts("Enter word (max 39 letters) ");
	gets_s(x1);

	/*
	записываем адреса начала
	оригинального  и результативного
	массивов в указатели
	*/
	px1 = x1;
	px2 = x2;

	/*
	вычисляем рельную длину
	оригинального массива
	*/
	n = strlen(x1) + 1;

	// цикл поэлементно перебирает
	// оригинальный массив
	while (k < n)
	{
		// если значение текущего элемента
		// не совпадает с 'a'
		if (*(px1 + k) != 'a')
		{
			// копируем текущий элемент
			// в результативный массив
			*(px2 + i) = *(px1 + k);
			// переходим к следующим элементам
			i++;
			k++;
		}
		// если значение текущего элемента
		// совпадает с 'a'
		else
		{
			// записываем символ 'k' в текущую
			// позицию результативного массива
			*(px2 + i) = 'k';
			// записываем символ 'y' в следующую
			// позицию результативного массива
			*(px2 + i + 1) = 'y';
			// переходим к следующему элементу
			// оригинального массива
			k++;
			// "перепрыгиваем" через один элемент
			// результативного массива
			i += 2;
		}
	}
	// демонстрируем результативный массив 
	puts(x2);

}

// замена всех сочетаний "ky" в слове X на букву "a"
void change_str2()
{
	/*
		k - переменная для прохода по оригинальному массиву
		i - переменная для прохода по результативному массиву
		n - длина оригинального массива
	*/
	int k = 0, i = 0, n;
	/*
		x1 - оригинальный массив
		x2 - результативный массив
		px1 - указатель для перемещения по оригинальному массиву
		px2 - указатель для перемещения по результативному массиву
	*/
	char x1[40], x2[40], *px1, *px2;

	// Запрос на ввод оригинального массива
	puts("Enter word (max 39 letters) ");
	gets_s(x1);

	/*
	записываем адреса начала
	оригинального  и результативного
	массивов в указатели
	*/
	px1 = x1;
	px2 = x2;

	/*
	вычисляем рельную длину
	оригинального массива
	*/
	n = strlen(x1) + 1;

	// цикл поэлементно перебирает
	// оригинальный массив
	while (k < n)
	{
		// проверяем, если два символа 
		// в текущей позиции оригинального
		// массива не совпадают с буквосочетанием "ky"
		if (strncmp((px1 + k), "ky", 2) != 0)
		{
			// просто копируем один символ
			// из текущей позиции в
			// результативный массив и 
			// передвигаемся на символ вперед
			*(px2 + i++) = *(px1 + k++);
		}
		// если же два символа
		// в текущей позиции оригинального
		// массива совпадают с буквосочетанием "ky"
		else
		{
			// записываем в результативный массив
			// символ 'a', и переходим на один 
			// символ вперед. В оригинальном переходим
			// на два символа вперед
			*(px2 + i++) = 'a';
			k += 2;
		}
	}
	// демонстрируем результативный массив
	puts(x2);
}

// удваивание каждой буквы слова Х
void change_str3()
{
	// n - длина оригинального массива *2	
	int n;

	/*
		x1 - оригинальный массив
		x2 - результативный массив (больше в два раза)
		px1 - указатель для перемещения по оригинальному массиву
		px2 - указатель для перемещения по результативному массиву
	*/
	char x1[40], x2[80], *px1, *px2;

	// Запрос на ввод оригинального массива
	puts("Enter word (max 39 letters) ");
	gets_s(x1);
	/*
	записываем адреса начала
	оригинального  и результативного
	массивов в указатели
	*/
	px1 = x1;
	px2 = x2;
	/*
	вычисляем двойную длину
	оригинального массива
	*/
	n = 2 * strlen(x1);

	// записываем в последний элемент 
	// результативного массива '\0'
	*(px2 + n) = '\0';

	// цикл поэлементно перебирает
	// оригинальный массив
	while ((*px1) != '\0')
	{
		// записываем значение из текущей позиции
		// оригинального массива в текущую позицию
		// результативного массива, в последнем
		// переходим на один элемент вперёд
		*px2++ = *px1;
		// записываем значение из текущей позиции
		// оригинального массива в текущую позицию
		// результативного массива, в обоих массивах
		// переходим на один элемент вперёд
		*px2++ = *px1++;
	}
	// демонстрируем результативный массив
	puts(x2);
}

