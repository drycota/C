#include "pch.h"

// Класс auto_ptr
/*
template<class X>

class Std::auto_ptr
{
	X* ptr;

public:

	//конструктор и деструктор

	explicit auto_ptr(X* p = 0)throw()
	{
		ptr = p;
	}

	~auto_ptr() throw()
	{
		delete ptr;
	}
	//оператор разыменования позволяет получить объект

	X& operator*()const throw()
	{
		return *ptr;
	}
		//оператор -> позволяет получить указатель

	X* operator->()const throw()
	{
		return ptr;
	}
};

#include <iostream>
#include <memory>
using namespace std;

class TEMP{
	public:
	TEMP(){
		cout<<"TEMP\n\n";
	}
	~TEMP(){
		cout<<"~TEMP\n\n";
	}
	void TEST(){
		cout<<"TEST\n\n";
	}
};
void main(){
	// создаём два автоматических указателя
	// под один из них выделяем память типа TEMP
	auto_ptr<TEMP>ptr1(new TEMP), ptr2;

	// передача права владения
	ptr2=ptr1;

	// вызов функции через автоматический указатель
	ptr2->TEST();

	// присваивание автоматического указателя
	// обычному указателю на объект класса
	TEMP*ptr=ptr2.get();

	// вызов функции через обычный указатель
	ptr->TEST();
}
*/

// Класс string
/*
// operator[] - доступ к конкретным символам в строке для чтения или записи.
// c_str() - конвертация строки в const char* для использования в функциях, не умеющих работать со string.
// append - добавление символов к концу строки.
// operator= - присваивание строке других строк, символьных массивов и даже чисел.
// insert - вставка символов или других строк в переменную типа string.
// erase - удаление одного или более символов из заданной строки в заданной позиции.
// replace - замещение одного или более символов в заданной позиции.
// length(или size) - возвращение количества символов в строке.
// empty - определение, есть ли в строке символы.
// find - нахождение первого вхождения символа или подстроки в данной строке.
// rfind - аналог find, но осуществляет поиск с конца строки назад.
// find_first_of - нахождение первого вхождения символов из набора в строке.
// substr - возвращение подстроки.
// find_first_not_of - нахождение первого символа в строке, не входящего в заданный набор.
// compare - сравнение строки (также поддерживаются операторы !=, <, >)

#include <stdio.h>
#include <stdlib.h>
#include <string>
using namespace std;

void main()
{
  // Присвоить строку символов объекту типа string
  string s = "Hello world";
  // Получить первое слово в строке
  int nWordEnd = s.find(' ');
  string sub_string = s.substr(0,nWordEnd);
  // Вывести результаты
  printf("String: %s\n", s.c_str());
  printf("Sub String: %s\n", sub_string.c_str());
}
*/

// Библиотека vector
/*
Класс vector поддерживает динамический массив и счетчик элементов, сохраненных в нем. Спецификация его шаблона имеет следующий вид:

template <class T, class Allocator = Allocator<T>>
class vector

Здесь T - тип сохраняемых данных, а Allocator задает распределитель. Класс vector имеет следующие конструкторы:

explicit vector(const Allocator &a = Allocator());
explicit vector(size_type num, const T &val = T(), const Allocator &a = Allocator());
vector(const vector <T,Allocator> &ob);
template < class InIter> vector(InIter start, InIter end, const Allocator &a = Allocator());

Первая форма конструктора создает пустой вектор. Вторая создает вектор, который создает num элементов со значением val. 
Третья создает вектор, который содержит те же элементы, что и вектор ob. Четвертая создает вектор, который содержит элементы в диапазоне, 
заданном параметрами start и end.

Для класса vector определены следующие операторы сравнения:
==
<
<=
!=
>
>=
Класс vector содержит следующие функции-члены:
--------------------------------------------------------------------------------
template <class InIter> void assign(InIter start, InIter end);
Помещает в вектор последовательность, определяемую параметрами start и end.
--------------------------------------------------------------------------------
void assign(size_type num, const T &val);
Помещает в вектор num элементов со значением val.
--------------------------------------------------------------------------------
reference at(size_type i);
const_reference at(size_type i) const;
Возвращает ссылку на элемент, заданный параметром i. При этом, в отличие от перегруженного оператора [] данная функция в случае выхода за пределы массива генерирует исключение.
--------------------------------------------------------------------------------
reference back();
const_reference back() const;
Возвращает ссылку на последний элемент в векторе.
--------------------------------------------------------------------------------
iterator begin();
const_iterator begin() const;
Возвращает итератор для первого элемента в векторе.
--------------------------------------------------------------------------------
size_type capacity() const;
Возвращает текущую ёмкость вектора, которая представляет собой количество элементов, способное храниться в векторе до того, как возникнет необходимость в выделении дополнительной памяти.
--------------------------------------------------------------------------------
void clear();
Удаляет все элементы из вектора.
--------------------------------------------------------------------------------
bool empty() const;
Возвращает значение истины, если используемый вектор пуст, и значение лжи в противном случае.
--------------------------------------------------------------------------------
const_iterator end() const;
iterator end();
Возвращает итератор для конца вектора.
--------------------------------------------------------------------------------
iterator erase(iterator i);
Удаляет элемент, адресуемый итератором i, возвращает итератор для элемента, расположенного после удаленного.
--------------------------------------------------------------------------------
iterator erase(iterator start, iterator end);
Удаляет элементы в диапазоне, задаваемом параметрами start и end, возвращает итератор для элемента, расположенного за последним удалённым элементом.
--------------------------------------------------------------------------------
reference front();
const_reference front() const;
Возвращает ссылку на первый элемент в векторе.
--------------------------------------------------------------------------------
allocator_type get_allocator() const;
Возвращает распределитель вектора.
--------------------------------------------------------------------------------
iterator insert(iterator i, const T &val = T());
Вставляет значение val непосредственно перед элементом, заданным параметром i, возвращает итератор для этого элемента.
--------------------------------------------------------------------------------
void insert(iterator i, size_type num, const T &val);
Вставляет num копий значения val непосредственно перед элементом, заданным параметром i.
--------------------------------------------------------------------------------
template <class InIter> void insert(iterator i, InIter start, InIter end);
Вставляет в вектор последовательность, определяемую параметрами start и end, непосредственно перед элементом, заданным параметром i.
--------------------------------------------------------------------------------
size_type max_size() const;
Возвращает максимальное число элементов, которое может содержать вектор.
--------------------------------------------------------------------------------
reference operator[](size_type i) const;
const_reference operator[](size_type i) const;
Возвращает ссылку на элемент, заданный параметром i.
--------------------------------------------------------------------------------
void pop_back();
Удаляет последний элемент в векторе.
--------------------------------------------------------------------------------
void push_back(const T &val);
Добавлчет в конец вектора элемент со значением, заданным параметром val.
--------------------------------------------------------------------------------
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
Возвращает реверсивный итератор для конца вектора.
--------------------------------------------------------------------------------
reverse_iterator rend();
const_reverse_iterator rend() const;
Возвращает реверсивный итератор для начала вектора.
--------------------------------------------------------------------------------
void reverse(size_type num);
Устанавливает емкость вектора равной не менее заданного значения num
--------------------------------------------------------------------------------
void resize(size_type num, const T &val = T());
Устанавливает емкость вектора равной не менее заданного значения num, если вектор для этого нужно удлинить, то в его конец добавляются элементы со значением, заданным параметром val.
--------------------------------------------------------------------------------
size_type size() const;
Возвращает текущее количество элементов в векторе.
--------------------------------------------------------------------------------
void swap(deque<T,Allocator> &ob);
Выполняет обмен элементами данного вектора и вектора ob.
--------------------------------------------------------------------------------
void flip();
Инвертирует значения всех битов в векторе.
--------------------------------------------------------------------------------
static void swap(reference i, reference j);
Переставляет местами биты, заданные параметрами i и j.
*/

// Библиотека list
/*
Класс list поддерживает работу двунаправленного связанного списка. Спецификация его шаблона выглядит следующим образом:

template <class T, class Allocator = Allocator<T>>
class list
Здесь T - тип данных, сохраняемых в списке. Класс list имеет следующие конструкторы:

explicit list(const Allocator &a = Allocator());
explicit list(size_type num, const T &val = T(), const Allocator &a = Allocator());
list(const list <T,Allocator> &ob);
template < class InIter> list(InIter start, InIter end, const Allocator &a = Allocator());

Первая форма конструктора создает пустой список. Вторая создает список, который содержит num элементов со значением val. 
Третья создает список, который содержит те же элементы, что и список ob. Четвертая создает список, который содержит элементы в диапазоне, заданном параметрами start и end.

Для класса list определены следующие операторы сравнения:
==
<
<=
!=
>
>=
Класс list содержит следующие функции-члены:
--------------------------------------------------------------------------------
template <class InIter> void assign(InIter start, InIter end);
Помещает в список последовательность, определяемую параметрами start и end.
--------------------------------------------------------------------------------
void assign(size_type num, const T &val);
Помещает в список num элементов со значением val.
--------------------------------------------------------------------------------
reference back();
const_reference back() const;
Возвращает ссылку на последний элемент в списке.
--------------------------------------------------------------------------------
iterator begin();
const_iterator begin() const;
Возвращает итератор для первого элемента в списке.
--------------------------------------------------------------------------------
void clear();
Удаляет все элементы из списка.
--------------------------------------------------------------------------------
bool empty() const;
Возвращает значение истины, если используемый список пуст, и значение лжи в противном случае.
--------------------------------------------------------------------------------
const_iterator end() const;
iterator end();
Возвращает итератор для конца списка.
--------------------------------------------------------------------------------
iterator erase(iterator i);
Удаляет элемент, адресуемый итератором i, возвращает итератор для элемента, расположенного после удаленного.
--------------------------------------------------------------------------------
iterator erase(iterator start, iterator end);
Удаляет элементы в диапазоне, задаваемом параметрами start и end, возвращает итератор для элемента, расположенного за последним удалённым элементом.
--------------------------------------------------------------------------------
reference front();
const_reference front() const;
Возвращает ссылку на первый элемент в списке.
--------------------------------------------------------------------------------
allocator_type get_allocator() const;
Возвращает распределитель списка.
--------------------------------------------------------------------------------
iterator insert(iterator i, const T &val = T());
Вставляет значение val непосредственно перед элементом, заданным параметром i, возвращает итератор для этого элемента.
--------------------------------------------------------------------------------
void insert(iterator i, size_type num, const T &val);
Вставляет num копий значения val непосредственно перед элементом, заданным параметром i.
--------------------------------------------------------------------------------
template <class InIter> void insert(iterator i, InIter start, InIter end);
Вставляет в список последовательность, определяемую параметрами start и end, непосредственно перед элементом, заданным параметром i.
--------------------------------------------------------------------------------
size_type max_size() const;
Возвращает максимальное число элементов, которое может содержать список.
--------------------------------------------------------------------------------
void merge(list<T,Allocator> &ob);
template <class Comp> void merge(list<T,Allocator> &ob, Comp cmpfn);
Объединяет упорядоченный список, содержащийся в объекте ob, с данным упорядоченным списком Результат также упорядочивается. 
После объединения список, содержащийся в объекте ob, остается пустым. Во второй форме может быть задана функция сравнения, 
которая определяет, когда один элемент меньше другого.
--------------------------------------------------------------------------------
void pop_back();
Удаляет последний элемент в списке.
--------------------------------------------------------------------------------
void pop_front();
Удаляет первый элемент в списке.
--------------------------------------------------------------------------------
void push_back(const T &val);
Добавляет в конец списка элемент со значением, заданным параметром val.
--------------------------------------------------------------------------------
void push_front(const T &val);
Добавляет в начало списка элемент со значением, заданным параметром val.
--------------------------------------------------------------------------------
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
Возвращает реверсивный итератор для конца списка.
--------------------------------------------------------------------------------
reverse_iterator rend();
const_reverse_iterator rend() const;
Возвращает реверсивный итератор для начала списка.
--------------------------------------------------------------------------------
void remove(const T &val);
Удаляет из списка элементы со значением, заданным параметром val.
--------------------------------------------------------------------------------
template <class UnPred> void remove_if(UnPred pr);
Удаляет элементы, для которых унарный предикат pr равен значению true.
--------------------------------------------------------------------------------
void resize(size_type num, const T &val = T());
Устанавливает емкость списка равной не менее заданного значения num, если вектор для этого нужно удлинить, то в его конец 
добавляются элементы со значением, заданным параметром val.
--------------------------------------------------------------------------------
void reverse();
Реверсирует список.
--------------------------------------------------------------------------------
size_type size() const;
Возвращает текущее количество элементов в списке.
--------------------------------------------------------------------------------
void sort();
template <class Comp> void sort(Comp cmpfn);
Сортирует список. Вторая форма сортирует список с помощью функции сравнения cmpfn, чтобы определять, когда один элемент меньше другого.
--------------------------------------------------------------------------------
void splice(iterator i, list<T,Allocator> &ob);
Вставляет содержимое списка ob в данный список в позиции, указанной итератором i, После выполнения этой операции список ob остается пустым.
--------------------------------------------------------------------------------
void splice(iterator i, list<T,Allocator> &ob, iterator el);
удаляет из списка ob элемент, адресуемый итератором el, и сохраняет его в позиции, адресуемой итератором i.
--------------------------------------------------------------------------------
void splice(iterator i, list<T,Allocator> &ob, iterator start, iterator end);
удаляет из списка ob диапазон, определяемый параметрами start и end, и сохраняет его в данном списке, начиная с позиции, адресуемой итератором i.
--------------------------------------------------------------------------------
void swap(list<T,Allocator> &ob);
Выполняет обмен элементами данного списка и списка ob.
--------------------------------------------------------------------------------
void unique();
template <class BinPred> void unique(BinPred pr);
Удаляет из списка элементы-дубликаты. Вторая форма для определения уникальности использует предикат pr.
*/

// Библиотека map
/*
Класс map поддерживает поддерживает ассоциативный контейнер, в котором уникальным ключам соответствуют определённые значения. 
Спецификация его шаблона имеет следующий вид:

template <class Key, class T, class Comp = less<key>,
class Allocator =Allocator<pair<const key, T>>>
class map

Здесь key - тип данных ключей,T - тип сохраняемых (отображемых)значений, а Comp - функция, которая сравнивает два ключа. Класс map имеет следующие конструкторы:

explicit map(const Comp &cmpfn = Comp(),Allocator &a = Allocator());
map(map<Key, T, Comp,Allocator> &ob);

template < class InIter> map(InIter start, InIter end,const Comp &cmpfn = Comp(),
 const Allocator &a = Allocator());

Первая форма конструктора создает пустое отображение. Вторая создает отображение, которое содержит те же элементы, что и отображение ob. 
Третья создает отображение, которое содержит элементы в диапазоне, заданном параметрами start и end. Функция, заданная параметром cmpfn 
(и если она задана), определяет упорядочение отображения.

Для класса map определены следующие операторы сравнения:
==
<
<=
!=
>
>=
Класс map содержит перечисленные ниже функции-члены. В приведенных описаниях элемент key_type представляет тип ключа, 
а элемент value_type - пару элементов pair<Key, T>.
--------------------------------------------------------------------------------
iterator begin();
const_iterator begin() const;
Возвращает итератор для первого элемента в отображении.
--------------------------------------------------------------------------------
void clear();
Удаляет все элементы из отображения.
--------------------------------------------------------------------------------
size_type count(const key_type &k) const;
Возвращает число вхождений ключа k в отображении (1 или 0).
--------------------------------------------------------------------------------
bool empty() const;
Возвращает значение true, если данное отображение пустое, и false в противном случае.
--------------------------------------------------------------------------------
const_iterator end() const;
iterator end();
Возвращает итератор, указывающий на конец отображения.
--------------------------------------------------------------------------------
pair<iterator, iterator> equal_range(const key_type &k);
pair<const_iterator, const_iterator> equal_range(const key_type &k) const;
Возвращает пару итераторов, которые указывают на первый и последний элементы в отображении, содержащие заданный ключ.
--------------------------------------------------------------------------------
void erase(iterator i);
Удаляет элемент, адресуемый итератором i.
--------------------------------------------------------------------------------
void erase(iterator start, iterator end);
Удаляет элементы в диапазоне, задаваемом параметрами start и end.
--------------------------------------------------------------------------------
size_type erase(const key_type &k);
Удаляет из отображения элементы, ключи которых имеют значение k.
--------------------------------------------------------------------------------
iterator find(const key_type &k);
const_iterator find(const key_type &k) const;
Возвращает итератор для заданного ключа. Если ключ не обнаружен, возвращает итератор до конца отображения.
--------------------------------------------------------------------------------
allocator_type get_allocator() const;
Возвращает распределитель отображения.
--------------------------------------------------------------------------------
iterator insert(iterator i, const value_type &val);
Вставляет значение val после элемента, заданным итератором i, возвращает итератор для этого элемента.
--------------------------------------------------------------------------------
template <class InIter> void insert(InIter start, InIter end);
Вставляет элементы заданного диапазона.
--------------------------------------------------------------------------------
pair<iterator, bool> insert(const value_type &val);
Вставляет значение val в используемое отображение. Возвращает итератор для данного отображения. Элемент вставляет только в том случае, 
если его еще нет в отображении. Если элемент был вставлен возвращает пару pair<iterator, true>, в противном случае pair<iterator, false>
--------------------------------------------------------------------------------
key_compare key_comp() const;
Возвращает объект-функцию, которая сравнивает ключи.
--------------------------------------------------------------------------------
iterator lower_bound(const key_type &k);
const_iterator lower_bound(const key_type &k) const;
Возвращает итератор для первого элемента в отображении, ключ которого равен значению k или больше этого значения.
--------------------------------------------------------------------------------
size_type max_size() const;
Возвращает максимальное число элементов, которое может содержать отображение.
--------------------------------------------------------------------------------
reference operator[](const key_type &i);
Возвращает ссылку на элемент, заданный параметром i. Если этого элемента не существует, вставляет его в отображение.
--------------------------------------------------------------------------------
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
Возвращает реверсивный итератор для конца отображения.
--------------------------------------------------------------------------------
reverse_iterator rend();
const_reverse_iterator rend() const;
Возвращает реверсивный итератор для начала отображения.
--------------------------------------------------------------------------------
size_type size() const;
Возвращает текущее количество элементов в отображении.
--------------------------------------------------------------------------------
void swap(map<Key, T, Comp, Allocator> &ob);
Выполняет обмен элементами данного отображения и отображения ob.
--------------------------------------------------------------------------------
iterator upper_bound(const key_type &k);
const_iterator upper_bound(const key_type &k) const;
Возвращает итератор для первого элемента в отображении, ключ которого больше заданного значения k.
--------------------------------------------------------------------------------
value_compare value_comp() const;
Возвращает объект-функцию, которая сравнивает значения.
--------------------------------------------------------------------------------
Этот класс предназначен для быстрого поиска значения по ключу. В качестве ключа может быть использовано все, что угодно, но при этом необходимо помнить, что главной особенностью ключа является возможность применить к нему операцию сравнения. Быстрый поиск значения по ключу осуществляется благодаря тому, что пары хранятся в отсортированном виде. Этот класс имеет недостаток - скорость вставки новой пары обратно пропорциональна количеству элементов, сохраненных в классе. Еще один важный момент - ключ должен быть уникальным.
*/

// Библиотека multimap
/*
Модифицированный вариант map, в котором отсутствует требования уникальности ключа - то есть, если произвести поиск по ключу, 
то вернется не одно значение, а набор значений, сохраненных с данным ключом.

Класс multimap поддерживает поддерживает ассоциативный контейнер, в котором неуникальным (в общем случае) ключам соответствуют 
определённые значения. Спецификация его шаблона имеет следующий вид:

template <class Key, class T, class Comp = less<key>,
class Allocator =Alloctor<pair<const key, T>>>
class multimap

Здесь key - тип данных ключей,T - тип сохраняемых (отображемых)значений, а Comp - функция, которая сравнивает два ключа. 
Класс multimap имеет следующие конструкторы:

explicit multimap(const Comp &cmpfn = Comp(),Allocator &a = Allocator());
multimap(multimap<Key, T, Comp,Allocator> &ob);
template < class InIter> multimap(InIter start, InIter end,const Comp &cmpfn = Comp(),
 const Allocator &a = Allocator());

Первая форма конструктора создает пустое мультиотображение. Вторая создает мультиотображение, которое содержит те же элементы, 
что и мультиотображение ob. Третья создает мультиотображение, которое содержит элементы в диапазоне, заданном параметрами start и end. 
Функция, заданная параметром cmpfn (и если она задана), определяет упорядочение мультиотображения.

Для класса multimap определены следующие операторы сравнения:
==
<
<=
!=
>
>=
Класс multimap содержит перечисленные ниже функции-члены. В приведенных описаниях элемент key_type представляет тип ключа, 
а элемент value_type - пару элементов pair<Key, T>.
--------------------------------------------------------------------------------
iterator begin();
const_iterator begin() const;
Возвращает итератор для первого элемента в мультиотображении.
--------------------------------------------------------------------------------
void clear();
Удаляет все элементы из мультиотображения.
--------------------------------------------------------------------------------
size_type count(const key_type &k) const;
Возвращает число вхождений ключа k в мультиотображении (1 или 0).
--------------------------------------------------------------------------------
bool empty() const;
Возвращает значение true, если данное мультиотображение пустое, и false в противном случае.
--------------------------------------------------------------------------------
const_iterator end() const;
iterator end();
Возвращает итератор, указывающий на конец мультиотображения.
--------------------------------------------------------------------------------
pair<iterator, iterator> equal_range(const key_type &k);
pair<const_iterator, const_iterator> equal_range(const key_type &k) const;
Возвращает пару итераторов, которые указывают на первый и последний элементы в мультиотображении, содержащие заданный ключ.
--------------------------------------------------------------------------------
void erase(iterator i);
Удаляет элемент, адресуемый итератором i.
--------------------------------------------------------------------------------
void erase(iterator start, iterator end);
Удаляет элементы в диапазоне, задаваемом параметрами start и end.
--------------------------------------------------------------------------------
size_type erase(const key_type &k);
Удаляет из мультиотображения элементы, ключи которых имеют значение k.
--------------------------------------------------------------------------------
iterator find(const key_type &k);
const_iterator find(const key_type &k) const;
Возвращает итератор для заданного ключа. Если ключ не обнаружен, возвращает итератор до конца мультиотображения.
--------------------------------------------------------------------------------
allocator_type get_allocator() const;
Возвращает распределитель мультиотображения.
--------------------------------------------------------------------------------
iterator insert(iterator i, const value_type &val);
Вставляет значение val после элемента, заданным итератором i, возвращает итератор для этого элемента.
--------------------------------------------------------------------------------
template <class InIter> void insert(InIter start, InIter end);
Вставляет элементы заданного диапазона.
--------------------------------------------------------------------------------
pair<iterator, bool> insert(const value_type &val);
Вставляет значение val в используемое мультиотображение. Возвращает итератор для данного мультиотображения. 
Элемент вставляет только в том случае, если его еще нет в мультиотображении. Если элемент был вставлен возвращает пару pair<iterator, true>, 
в противном случае pair<iterator, false>
--------------------------------------------------------------------------------
key_compare key_comp() const;
Возвращает объект-функцию, которая сравнивает ключи.
--------------------------------------------------------------------------------
iterator lower_bound(const key_type &k);
const_iterator lower_bound(const key_type &k) const;
Возвращает итератор для первого элемента в мультиотображении, ключ которого равен значению k или больше этого значения.
--------------------------------------------------------------------------------
size_type max_size() const;
Возвращает максимальное число элементов, которое может содержать мультиотображение.
--------------------------------------------------------------------------------
reference operator[](const key_type &i);
Возвращает ссылку на элемент, заданный параметром i. Если этого элемента не существует, вставляет его в мультиотображение.
--------------------------------------------------------------------------------
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
Возвращает реверсивный итератор для конца мультиотображения.
--------------------------------------------------------------------------------
reverse_iterator rend();
const_reverse_iterator rend() const;
Возвращает реверсивный итератор для начала мультиотображения.
--------------------------------------------------------------------------------
size_type size() const;
Возвращает текущее количество элементов в мультиотображении.
--------------------------------------------------------------------------------
void swap(multimap<Key, T, Comp, Allocator> &ob);
Выполняет обмен элементами данного мультиотображения и мультиотображения ob.
--------------------------------------------------------------------------------
iterator upper_bound(const key_type &k);
const_iterator upper_bound(const key_type &k) const;
Возвращает итератор для первого элемента в мультиотображении, ключ которого больше заданного значения k.
--------------------------------------------------------------------------------
value_compare value_comp() const;
Возвращает объект-функцию, которая сравнивает значения.
*/

// Использование функторов
/*
// Функторы (иначе говоря, функциональные объекты) - это специализированный вид классов, которые включают в себя перегруженный 
// оператор вызова функции. Как правило, функтор можно применить везде, где требуется функция. Проще говоря, когда должна быть вызвана 
// функция, вызывается перегруженный оператор вызова функции.(оператор "круглые скобки").

// Реализуем таблицу умножения. Требования следующие: первый множитель увеличивается слева направо, второй - сверху вниз.
// библиотека для работы алгоритмов

#include <algorithm>
#include <iostream>
// библиотека контейнера списка
#include <list>
using namespace std;

// Функциональный объект, содержащий два поля:
// 1. для хранения значения приращения (delta)
// 2. для текущего значения генерируемого числа (current)

class addNumberFrom
{
	int delta;
	int current;
	
	// Конструктор класса инициализирует значение приращения и текущее значение.
	// Последнее может быть опущено, и тогда оно будет считаться равным 0
	
public:
	addNumberFrom(int number, int from = 0) :delta(number), current(from) {}

	// Основа функтора - перегруженный оператор вызова функции
	// - прибавляет значение приращения к текущему генерируемому числу
	
	int operator()()
	{
		return current += delta;
	}
};

// Вывод заголовка для таблицы умножения.

void main()
{
	cout << "TABLE:" << "\n\n";
	cout << "----------" << "\n\n";

	for (int i = 1; i <= 10; i++)
	{
		// Cоздание контейнера-списка.
		list<int> l(10);
		
		// Вызов алгоритма generate_n. Естественно, сам он не может ничего генерировать,
		// однако последовательно перебирает значения, диапазон которых задан
		// начальным итератором и количеством элементов списка.
		// Для записи числа в каждое значение вызывается функция,
		// на которую ссылается третий параметр:

		generate_n(l.begin(), l.size(), addNumberFrom(i));

		// Но мы вместо функции подставляем перегруженный оператор
		// вызова функции - объект addNumberFrom. Если вызов происходит
		// впервые, то вызывается конструктор объекта. Он инициализирует поле delta значением переменной i,
		// а поле current - значением по умолчанию второго параметра конструктора, т. е. 0.

		// Таким образом, контейнер-список заполняется произведениями числа
		// в переменной i и множителями от 1 до 10. В алгоритме generate_n используется
		// метод size(), который возвращает количество элементов в списке.
		// Если имеются начальный и конечные итераторы,
		// тогда лучше воспользоваться алгоритмом generate.

		// Собственно показ числа из контейнера-списка

		copy(l.begin(), l.end(), ostream_iterator<int>(cout, "\t"));
	}
}
*/

// Встроенные функторы
/*
Арифметические функторы
plus сложение x + y
minus вычитание x - y
multiplies умножение x х y
divides деление x / y
modulus взятие остатка x % y
negate обращение знака - x

Функторы сравнения
equal_to равно x == y
not_equal_to не равно x != y
greater больше x > y
less меньше x < y
greater_equal больше или равно x => y
less_equal меньше или равно x <= y

Логические функторы
logical_and логическое "и" x && y
logical_or логическое "или" x || y
logical_not логическое "не" ! x
*/

// Использование предикатов
/*
// Предикат - специальная функция, которая возвращает логическое значение (true либо false). 

// Предикат, определяющий четность числа
// Эту задачу решает алгоритм remove_if. Обратите внимания, что многие алгоритмы, оканчивающиеся на _if, в качестве последнего 
// параметра используют предикаты. Алгоритм remove_if сдвигает все подходящие значения в начало контейнера и возвращает итератор, 
// который указывает на элемент, следующий за удаляемыми значениями. По этой причине, мы будем считать, что начиная с адреса, 
// на который ссылается возвращаемый итератор, и до конца области данных контейнера располагаются неудаленные значения, 
// для которых предикат вернул false. Здесь, в нашем примере, мы используем данную особенность следующим образом: все четные 
// значения выводятся на экран (для этого мы копируем их в поток вывода, передав потоковому итератору пару итераторов, 
// которые описывают область удаленных значений.)

#include <algorithm>
#include <iostream>
#include <list>
using namespace std;

// предикат
bool isEven(int num)
{
  return bool(num % 2);
}

void main()
{
	list<int> l;
	list<int>::iterator t;

	for(int i=1; i<=10; i++)
		l.push_back(i);

	copy(l.begin(), l.end(), ostream_iterator<int>(cout," "));
	cout<<"\n\n";
	t=remove_if(l.begin(), l.end(), isEven);
	copy(l.begin(), t, ostream_iterator<int>(cout," "));
}
*/

// Использование алгоритмов
/*
#include <algorithm>
Немодифицирующие операции.
for_earch() - выполняет операции для каждого элемента последовательности
find() - находит первое вхождение значения в последовательность
find_if() - находит первое соответствие предикату в последовательности
count() - подсчитывает количество вхождений значения в последовательность
count_if() - подсчитывает количество выполнений предиката в последовательности
search() - находит первое вхождение последовательности как подпоследовательности
search_n()- находит в последовательности подпоследовательность, состоящую из n повторений и возвращает её первое вхождение.
Модифицирующие операции.
copy() - копирует последовательность, начиная с первого элемента
swap() - меняет местами два элемента
replace() - заменяет элементы с указанным значением
replace_if() - заменяет элементы при выполнении предиката
replace_copy() - копирует последовательность, заменяя элементы с указанным значением
replace_copy_if() - копирует последовательность, заменяя элементы при выполнении предиката
fill() - заменяет все элементы данным значением
remove() - удаляет элементы с данным значением
remove_if() - удаляет элементы при выполнении предиката
remove_copy() - копирует последовательность, удаляя элементы с указанным значением
remove_copy_if() - копирует последовательность, удаляя элементы при выполнении предиката
reverse() - меняет порядок следования элементов на обратный
random_shuffle() - перемещает элементы согласно случайному равномерному распределению ("тасует" последовательность)
transform() - выполняет заданную операцию над каждым элементом последовательности
unique() - удаляет равные соседние элементы
unique_copy() - копирует последовательность, удаляя равные соседние элементы
Сортировка.
sort() - сортирует последовательность с хорошей средней эффективностью
partial_sort() - сортирует часть последовательности
stable_sort() - сортирует последовательность, сохраняя порядок следования равных элементов
lower_bound() - находит первый элемент, меньший чем заданное значение
upper_bound() - находит первый элемент, больший чем заданное значение
binary_search() - определяет, есть ли данный элемент в отсортированной последовательности
merge() - сливает две отсортированные последовательности
Работа с множествами.
includes() - проверка на вхождение
set_union() - объединение множеств
set_intersection() - пересечение множеств
set_difference() - разность множеств
Минимумы и максимумы.
min() - меньшее из двух
max() - большее из двух
min_element() - наименьшее значение в последовательности
max_element() - наибольшее значение в последовательности
Перестановки.
next_permutation() - следующая перестановка в лексикографическом порядке
prev_permutation() - предыдущая перестановка в лексикографическом порядке
*/

